# 第 18 章 - 迭代法 Iterative 

## 迭代法

話說《迭代法》，感覺非常神奇，但是說穿了很簡單！

迭代法的關鍵，可以說是一種《函數不動點》的尋找！ 

$$x=f(x)$$

$$x_2 =f(x_1)$$

$$x_3 =f(x_2)$$

... 

$$x_{k+1} =f(x_k)$$


所謂的不動點，就是 x=f(x) 這樣一個方程式。我們從 k=0 開始反覆用 $$x_{k+1} =f(x_k)$$ 去找下一個 $$x_{k+1}$$，當我們找到符合 x_{k+1} =f(x_k) 的 x 時， x 基本上就定住了，這時我們找到的 x 就是 x=f(x) 的一個解答！

問題是，如果我們並非想找 f(x)=x 的解，而是 f(x)=0 的解呢？ 那該怎麼辦？

其實答案很簡單， 只要修改方程式，想辦法讓 x 出 現在其中一邊就行了。

舉例而言， 假如我們想要找 f(x)=0 的解， 那麼我們可以對兩邊各加一個 x ，變成 f(x)+x = x 該等式仍然會成立。這樣就可以進行迭代了！

當然、迭代的形式不只一種， 對於 f(x)=0，以下都是可以用的迭代形式。


$$x=f(x)+x$$

$$x^2=f(x)+x^2 => x=\frac{f(x)+x^2}{x}$$

$$3x^3=f(x)+3x^3 => x=\frac{f(x)+3x^3}{3x^2}$$

$$f(x)/4=0 => x=x-f(x)/4$$

於是、您只要選擇一個起點， 像是 x=3 ，然後開始反複套用迭代公式，看看是否會收斂就行了！

假如我們的迭代公式是 x=g(x)，那麼只要隨便選一個起點，例如 x1=3，然後用 x2 =g(x1)，x3=g(x2) … 一直算下去，直到收斂為止。

以下是一個迭代法的程式範例， 用來尋找 $$x*x-4*x+1$$ 的解！

```javascript
function f(x) { return x*x-4*x+1; }

function g(x) { return x-f(x)/4; }

function isolve(g, x) {
	console.log("x=", x);
  for (var i=0; i<100000; i++) {
    if (Math.abs(x-g(x)) < 0.001)
      return x;
    x = g(x);
	  console.log("x=", x);
  }
	return x;
}

var x = isolve(g, 1);
console.log("x=", x, "f(x)=", f(x));
```

執行結果：

```
D:\Dropbox\gitbook\rlab\code\solveEquation>node iteration.js
x= 1
x= 1.5
x= 2.1875
x= 2.9287109375
x= 3.4630849361419678
x= 3.6779305535505813
x= 3.7240678179159414
x= 3.7309653577225825
x= 3.7309653577225825 f(x)= -0.0037589303643326133
```

這種迭代法，其實幾乎可以用來解所有的方程式，最大的問題是《可能不會收斂》！，

而且不同的迭代方法，收斂速度也常 常有差異

在此我們舉一個簡單的例子， 假如您想求某個數的平方根。那麼可以用下列三種的迭代算式

1. $$x_{k+1} = \frac{3}{x_k}$$
2. $$x_{k+1} = x_k - \frac{1}{4} (x^2_k -3)$$
3. $$x_{k+1} = \frac{1}{2} (x_k + \frac{3}{x_k})$$

然後實作這三種方法，程式碼如下：

檔案： iterative.js

```javascript
var f1=(x)=>3/x;
var f2=(x)=>x-1/4*(x*x-3);
var f3=(x)=>1/2*(x+3/x);

x1=x2=x3=1;
for (var i=0; i<20; i++) {
  x1=f1(x1);	x2=f2(x2);	x3=f3(x3);
	console.log("x1:", x1, "x2", x2, "x3", x3);
}
```

執行結果

```
D:\Dropbox\cccwd\db\sc1\code>node iterative
x1: 3 x2 1.5 x3 2
x1: 1 x2 1.6875 x3 1.75
x1: 3 x2 1.7255859375 x3 1.7321428571428572
x1: 1 x2 1.7311742305755615 x3 1.7320508100147274
x1: 3 x2 1.7319331764233397 x3 1.7320508075688772
x1: 1 x2 1.73203504452438 x3 1.7320508075688772
x1: 3 x2 1.7320486956592371 x3 1.7320508075688772
x1: 1 x2 1.732050524625521 x3 1.7320508075688772
x1: 3 x2 1.7320507696616354 x3 1.7320508075688772
x1: 1 x2 1.7320508024902694 x3 1.7320508075688772
x1: 3 x2 1.732050806888473 x3 1.7320508075688772
x1: 1 x2 1.7320508074777203 x3 1.7320508075688772
x1: 3 x2 1.7320508075566647 x3 1.7320508075688772
x1: 1 x2 1.7320508075672412 x3 1.7320508075688772
x1: 3 x2 1.7320508075686583 x3 1.7320508075688772
x1: 1 x2 1.7320508075688479 x3 1.7320508075688772
x1: 3 x2 1.7320508075688732 x3 1.7320508075688772
x1: 1 x2 1.7320508075688767 x3 1.7320508075688772
x1: 3 x2 1.7320508075688772 x3 1.7320508075688772
x1: 1 x2 1.7320508075688772 x3 1.7320508075688772
```

這三種方法的收斂情形如下圖：

![](img/iteration.png)

因此、好的迭代算式可以讓你上天堂，不好的迭代算式會讓你住牢房！

如果想要確定迭代法會收斂， 必須要好好的設計《迭代函數》 與《初始值》才行！

當然、有人可能會問， 假如我想解的不是方程式，而是像下列的這種《方程組》的話，那該怎麼辦呢？

![](img/equationSet.png)

其實這個問題， 只要稍微轉換一下，就可以讓 《方程組變成單一的方程式》

假如您想求解下列方程組

```
  f(x)=0
  g(x)=0
```

那麼只要改寫為


$$f^2(x) +g^2(x) = 0$$

就可以《將方程組變成方程式》了。

只是這樣一來，線性的方程組就有可能變成了 《二次的非線性方程式》

這就是，用解方程式的方法來解方程組，所需要付出的代價了。

不過迭代法確實是一個，很好的《數值方法》 可以用來解很多方程式。

